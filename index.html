<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <title>리듬게임</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <style>
    :root { --max-width: 900px; }
    * { box-sizing: border-box; }
    html, body {
      margin: 0;
      font-family: system-ui, -apple-system, "Segoe UI", Roboto, sans-serif;
      -webkit-text-size-adjust: 100%;
      background: #000;
      color: #fff;
    }
    body { display: flex; flex-direction: column; align-items: center; padding: 16px; }

    /* ✅ 로고 */
    h1.title-logo{
      margin: 0 0 6px;
      padding: 0;
      text-align: center;
      line-height: 0;
      font-size: 0;
    }
    .logo-box{
      width: min(260px, 46vw);
      aspect-ratio: 1920 / 696;
      margin: 0 auto;
      overflow: visible;
    }
    .logo-box img{
      width: 100%;
      height: 100%;
      display: block;
      object-fit: contain;
      object-position: center;
    }

    .bar {
      width: 100%; max-width: var(--max-width);
      display: flex; justify-content: center; gap: 12px;
      align-items: center;
    }
    .bar.menu { flex-wrap: nowrap; }
    .bar.menu > button, .bar.menu > .score-box { flex: 1 1 0; min-width: 0; }

    button {
      font-size: clamp(16px, 4.5vw, 18px);
      padding: 14px 18px; min-height: 48px;
      border-radius: 12px; border: 1px solid #222; background:#0b0b0b;
      box-shadow: 0 1px 0 rgba(0,0,0,0.06); cursor: pointer; color:#fff;
      white-space: nowrap;
    }
    button:active { transform: translateY(1px); }
    button:disabled { opacity: .5; cursor: not-allowed; }

    .score-box{
      display:none;
      align-items:center;
      justify-content:center;
      font-size: clamp(16px, 4.5vw, 18px);
      padding: 14px 18px; min-height: 48px;
      border-radius: 12px; border: 1px solid #222; background:#0b0b0b;
      font-weight: 900;
      color:#fff;
      user-select:none;
      flex: 1 1 auto;
      min-width: 0;
    }
    .score-box span{ margin-left:8px; }

    #btnRetry{
      display:none;
      flex: 0 0 auto;
    }

    #content { width: 100%; max-width: var(--max-width); margin-top: 12px; }

    .input-row { display:flex; align-items:center; justify-content:center; gap:10px; margin: 10px 0; }
    label { font-size: clamp(15px, 4.2vw, 17px); }
    input[type="text"] {
      font-size: clamp(16px, 4.8vw, 18px);
      padding: 12px 14px; min-height: 48px;
      width: min(420px, 80vw);
      border: 1.2px solid #222; border-radius: 10px; background: #0b0b0b; color:#fff;
      outline: none;
    }
    input[type="text"].invalid { border-color: #ff4d4d; }

    p { margin: 10px 0; font-size: clamp(15px, 4.2vw, 17px); text-align:center; color:#ddd; }

    canvas {
      width: 100%;
      display: block; margin: 0 auto; border: 1px solid #222;
      touch-action: manipulation; background: transparent;
    }

    /* preview */
    .preview-row { display:flex; gap:12px; align-items:center; justify-content:center; margin-top:8px; }
    .preview-wrap{ display:flex; gap:12px; align-items:center; }
    .preview-canvas{ width: 220px; height: 140px; border: 1px solid #222; border-radius:8px; background: #020202; }
    .preview-controls { display:flex; flex-direction:column; gap:8px; min-width:160px; }
    .preview-controls label{ font-size:14px; }
    .range-row{ display:flex; gap:8px; align-items:center; }
    input[type=range]{ width:100%; }

    /* ✅ 게임 중 스크롤 방지 */
    body.lock-scroll {
      position: fixed;
      left: 0;
      right: 0;
      width: 100%;
      overflow: hidden;
      touch-action: none;
    }

    /* ✅ 게임 중 상단바 얇게 */
    .bar.menu.compact button,
    .bar.menu.compact .score-box{
      min-height: 40px;
      padding: 10px 12px;
      border-radius: 10px;
    }

    body.playing #content { margin-top: 6px; }

    /* ✅ 랭킹 */
    .rank-wrap{
      border: 1px solid #222;
      border-radius: 12px;
      overflow: hidden;
      background: #070707;
    }
    .rank-head{
      display:flex;
      justify-content: space-between;
      align-items:center;
      padding: 12px 14px;
      border-bottom: 1px solid #222;
      gap: 10px;
    }
    .rank-head strong{ font-size: 18px; }
    .rank-actions{ display:flex; gap: 8px; }
    .rank-table{
      width: 100%;
      border-collapse: collapse;
      font-size: 14px;
    }
    .rank-table th, .rank-table td{
      padding: 10px 10px;
      border-bottom: 1px solid #151515;
      text-align: left;
      color:#ddd;
    }
    .rank-table th{
      color:#fff;
      background: #0b0b0b;
      font-weight: 800;
    }
    .muted{ color:#aaa; font-size: 13px; }
  </style>
</head>

<body>
  <h1 class="title-logo">
    <div class="logo-box">
      <img src="assets/logo.png" alt="RHYTHM BREAK 로고">
    </div>
  </h1>

  <div class="bar menu" id="topBar">
    <button id="btnStart">게임 시작</button>
    <button id="btnRank">랭킹 확인</button>

    <div class="score-box" id="scoreBox">점수 <span id="scoreTop">0</span></div>
    <button id="btnRetry">다시하기</button>
  </div>

  <div id="content"></div>

  <script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/12.7.0/firebase-app.js";
    import {
    getFirestore, collection, serverTimestamp,
    getDocs, query, orderBy, limit,
    doc, runTransaction
  } from "https://www.gstatic.com/firebasejs/12.7.0/firebase-firestore.js";


    // ==============================
    // Firebase
    // ==============================
    const firebaseConfig = {
      apiKey: "AIzaSyBxOnlL3ugTshph4CpWFSkE9BE-qgRgPlQ",
      authDomain: "rhythm-break.firebaseapp.com",
      projectId: "rhythm-break",
      storageBucket: "rhythm-break.firebasestorage.app",
      messagingSenderId: "355457273272",
      appId: "1:355457273272:web:04d5594b19c09add22534d",
      measurementId: "G-RTXSJM3DJN"
    };

    const app = initializeApp(firebaseConfig);
    const db = getFirestore(app);

    function makeScoreDocId(studentId, name) {
  // Firestore 문서ID는 "/" 같은 문자가 있으면 안 돼서 안전하게 인코딩
  return `${encodeURIComponent(studentId)}__${encodeURIComponent(name)}`;
}

async function submitScore({ studentId, name, score, playTimeMs }) {
  studentId = (studentId || "").trim();
  name = (name || "").trim();

  const id = makeScoreDocId(studentId, name);
  const ref = doc(db, "scores", id);

  await runTransaction(db, async (tx) => {
    const snap = await tx.get(ref);

    if (!snap.exists()) {
      // 최초 기록
      tx.set(ref, {
        studentId, name,
        score,
        playTimeMs,
        createdAt: serverTimestamp(),
        updatedAt: serverTimestamp(),
      });
      return;
    }

    const prev = snap.data() || {};
    const prevScore = Number(prev.score || 0);

    // ✅ 더 높은 점수일 때만 덮어쓰기
    if (score > prevScore) {
      tx.update(ref, {
        score,
        playTimeMs,
        updatedAt: serverTimestamp(),
      });
    }
  });
}


    async function fetchTopScores(max = 20) {
      const q = query(
        collection(db, "scores"),
        orderBy("score", "desc"),
        limit(max)
      );
      const snap = await getDocs(q);
      return snap.docs.map(d => ({ id: d.id, ...d.data() }));
    }

    // ==============================
    // ✅ 운영용 배치 데이터
    // ==============================
    const PLACEMENT_CODE = String.raw`
setTimeout(() => createCircle(280, 436), beatToMs(4));
setTimeout(() => createCircle(280, 329), beatToMs(8));
setTimeout(() => createCircle(280, 215), beatToMs(12));
setTimeout(() => createCircle(280, 113), beatToMs(16));
setTimeout(() => createCircle(280, 435), beatToMs(20));
setTimeout(() => createCircle(280, 541), beatToMs(24));
setTimeout(() => createCircle(280, 635), beatToMs(28));
setTimeout(() => createCircle(280, 741), beatToMs(32));
setTimeout(() => createCircle(80, 897), beatToMs(33));
setTimeout(() => createCircle(80, 781), beatToMs(34));
setTimeout(() => createCircle(80, 669), beatToMs(35));
setTimeout(() => createCircle(80, 569), beatToMs(36));
setTimeout(() => createCircle(80, 465), beatToMs(37));
setTimeout(() => createCircle(80, 355), beatToMs(38));
setTimeout(() => createCircle(80, 263), beatToMs(39.5));
setTimeout(() => createCircle(80, 177), beatToMs(40));
setTimeout(() => createCircle(460, 61), beatToMs(41));
setTimeout(() => createCircle(460, 148), beatToMs(42));
setTimeout(() => createCircle(460, 244), beatToMs(43));
setTimeout(() => createCircle(460, 333), beatToMs(44));
setTimeout(() => createCircle(460, 448), beatToMs(45));
setTimeout(() => createCircle(460, 535), beatToMs(46));
setTimeout(() => createCircle(460, 635), beatToMs(47.5));
setTimeout(() => createCircle(460, 725), beatToMs(48));
setTimeout(() => createCircle(80, 897), beatToMs(49));
setTimeout(() => createCircle(80, 781), beatToMs(50));
setTimeout(() => createCircle(80, 669), beatToMs(51));
setTimeout(() => createCircle(80, 569), beatToMs(52));
setTimeout(() => createCircle(80, 465), beatToMs(53));
setTimeout(() => createCircle(80, 355), beatToMs(54));
setTimeout(() => createCircle(80, 263), beatToMs(55.5));
setTimeout(() => createCircle(80, 177), beatToMs(56));
setTimeout(() => createCircle(460, 61), beatToMs(57));
setTimeout(() => createCircle(460, 148), beatToMs(58));
setTimeout(() => createCircle(460, 244), beatToMs(59));
setTimeout(() => createCircle(460, 333), beatToMs(60));
setTimeout(() => createCircle(460, 448), beatToMs(61));
setTimeout(() => createCircle(460, 535), beatToMs(62));
setTimeout(() => createCircle(460, 635), beatToMs(63.5));
setTimeout(() => createCircle(460, 725), beatToMs(64));
setTimeout(() => createCircle(80, 897), beatToMs(65));
setTimeout(() => createCircle(80, 781), beatToMs(66));
setTimeout(() => createCircle(80, 669), beatToMs(67));
setTimeout(() => createCircle(80, 569), beatToMs(68));
setTimeout(() => createCircle(80, 465), beatToMs(69));
setTimeout(() => createCircle(80, 355), beatToMs(70));
setTimeout(() => createCircle(80, 263), beatToMs(71.5));
setTimeout(() => createCircle(80, 177), beatToMs(72));
setTimeout(() => createCircle(460, 61), beatToMs(73));
setTimeout(() => createCircle(460, 148), beatToMs(74));
setTimeout(() => createCircle(460, 244), beatToMs(75));
setTimeout(() => createCircle(460, 333), beatToMs(76));
setTimeout(() => createCircle(460, 448), beatToMs(77));
setTimeout(() => createCircle(460, 535), beatToMs(78));
setTimeout(() => createCircle(460, 635), beatToMs(79.5));
setTimeout(() => createCircle(460, 725), beatToMs(80));
setTimeout(() => createCircle(120, 860), beatToMs(81));
setTimeout(() => createCircle(120, 90), beatToMs(82));
setTimeout(() => createCircle(420, 90), beatToMs(83));
setTimeout(() => createCircle(420, 860), beatToMs(84));
setTimeout(() => createCircle(160, 660), beatToMs(85));
setTimeout(() => createCircle(160, 250), beatToMs(86));
setTimeout(() => createCircle(360, 250), beatToMs(87.5));
setTimeout(() => createCircle(360, 660), beatToMs(88));
setTimeout(() => createCircle(410, 790), beatToMs(89));
setTimeout(() => createCircle(310, 790), beatToMs(90));
setTimeout(() => createCircle(210, 790), beatToMs(91));
setTimeout(() => createCircle(110, 790), beatToMs(92));
setTimeout(() => createCircle(110, 200), beatToMs(93));
setTimeout(() => createCircle(210, 200), beatToMs(94));
setTimeout(() => createCircle(310, 200), beatToMs(95.5));
setTimeout(() => createCircle(410, 200), beatToMs(96));
setTimeout(() => createCircle(360, 560), beatToMs(97));
setTimeout(() => createCircle(360, 460), beatToMs(98));
setTimeout(() => createCircle(360, 360), beatToMs(99));
setTimeout(() => createCircle(360, 260), beatToMs(100));
setTimeout(() => createCircle(170, 260), beatToMs(101));
setTimeout(() => createCircle(170, 360), beatToMs(102));
setTimeout(() => createCircle(170, 460), beatToMs(103.5));
setTimeout(() => createCircle(170, 560), beatToMs(104));
setTimeout(() => createCircle(110, 640), beatToMs(105));
setTimeout(() => createCircle(210, 640), beatToMs(106));
setTimeout(() => createCircle(310, 640), beatToMs(107.5));
setTimeout(() => createCircle(410, 640), beatToMs(108));
setTimeout(() => createCircle(410, 360), beatToMs(109));
setTimeout(() => createCircle(310, 360), beatToMs(110));
setTimeout(() => createCircle(210, 360), beatToMs(111.5));
setTimeout(() => createCircle(110, 360), beatToMs(112));
setTimeout(() => createCircle(200, 875), beatToMs(113));
setTimeout(() => createCircle(310, 875), beatToMs(113));
setTimeout(() => createCircle(200, 775), beatToMs(114));
setTimeout(() => createCircle(310, 775), beatToMs(114));
setTimeout(() => createCircle(200, 675), beatToMs(115));
setTimeout(() => createCircle(310, 675), beatToMs(115));
setTimeout(() => createCircle(200, 575), beatToMs(116));
setTimeout(() => createCircle(310, 575), beatToMs(116));
setTimeout(() => createCircle(110, 500), beatToMs(117));
setTimeout(() => createCircle(210, 500), beatToMs(118));
setTimeout(() => createCircle(310, 500), beatToMs(119.5));
setTimeout(() => createCircle(410, 500), beatToMs(120));
setTimeout(() => createCircle(200, 100), beatToMs(121));
setTimeout(() => createCircle(310, 100), beatToMs(121));
setTimeout(() => createCircle(200, 200), beatToMs(122));
setTimeout(() => createCircle(310, 200), beatToMs(122));
setTimeout(() => createCircle(200, 300), beatToMs(123));
setTimeout(() => createCircle(310, 300), beatToMs(123));
setTimeout(() => createCircle(200, 400), beatToMs(124));
setTimeout(() => createCircle(310, 400), beatToMs(124));
setTimeout(() => createCircle(110, 470), beatToMs(125));
setTimeout(() => createCircle(210, 470), beatToMs(126));
setTimeout(() => createCircle(310, 470), beatToMs(127.5));
setTimeout(() => createCircle(410, 470), beatToMs(128));
setTimeout(() => createCircle(80, 897), beatToMs(129));
setTimeout(() => createCircle(80, 781), beatToMs(130));
setTimeout(() => createCircle(80, 669), beatToMs(131));
setTimeout(() => createCircle(80, 569), beatToMs(132));
setTimeout(() => createCircle(80, 465), beatToMs(133));
setTimeout(() => createCircle(80, 355), beatToMs(134));
setTimeout(() => createCircle(80, 263), beatToMs(135.5));
setTimeout(() => createCircle(80, 177), beatToMs(136));
setTimeout(() => createCircle(460, 61), beatToMs(137));
setTimeout(() => createCircle(460, 148), beatToMs(138));
setTimeout(() => createCircle(460, 244), beatToMs(139));
setTimeout(() => createCircle(460, 333), beatToMs(140));
setTimeout(() => createCircle(460, 448), beatToMs(141));
setTimeout(() => createCircle(460, 535), beatToMs(142));
setTimeout(() => createCircle(460, 635), beatToMs(143.5));
setTimeout(() => createCircle(460, 725), beatToMs(144));
setTimeout(() => createCircle(120, 200), beatToMs(145));
setTimeout(() => createCircle(120, 360), beatToMs(146));
setTimeout(() => createCircle(230, 280), beatToMs(147));
setTimeout(() => createCircle(315, 250), beatToMs(148.5));
setTimeout(() => createCircle(315, 365), beatToMs(149));
setTimeout(() => createCircle(430, 365), beatToMs(150));
setTimeout(() => createCircle(430, 250), beatToMs(151));
setTimeout(() => createCircle(400, 850), beatToMs(153));
setTimeout(() => createCircle(400, 690), beatToMs(154));
setTimeout(() => createCircle(280, 770), beatToMs(155));
setTimeout(() => createCircle(205, 840), beatToMs(156.5));
setTimeout(() => createCircle(205, 725), beatToMs(157));
setTimeout(() => createCircle(90, 725), beatToMs(158));
setTimeout(() => createCircle(90, 840), beatToMs(159));
setTimeout(() => createCircle(140, 100), beatToMs(160.5));
setTimeout(() => createCircle(265, 100), beatToMs(161.5));
setTimeout(() => createCircle(390, 100), beatToMs(162.5));
setTimeout(() => createCircle(180, 150), beatToMs(164));
setTimeout(() => createCircle(340, 150), beatToMs(164));
setTimeout(() => createCircle(180, 225), beatToMs(164.5));
setTimeout(() => createCircle(340, 225), beatToMs(164.5));
setTimeout(() => createCircle(180, 300), beatToMs(166.5));
setTimeout(() => createCircle(340, 300), beatToMs(166.5));
setTimeout(() => createCircle(180, 375), beatToMs(167.5));
setTimeout(() => createCircle(340, 375), beatToMs(167.5));
setTimeout(() => createCircle(390, 860), beatToMs(169.5));
setTimeout(() => createCircle(265, 860), beatToMs(170.5));
setTimeout(() => createCircle(140, 860), beatToMs(171.5));
setTimeout(() => createCircle(340, 810), beatToMs(173));
setTimeout(() => createCircle(180, 810), beatToMs(173));
setTimeout(() => createCircle(340, 735), beatToMs(173.5));
setTimeout(() => createCircle(180, 735), beatToMs(173.5));
setTimeout(() => createCircle(340, 660), beatToMs(174.5));
setTimeout(() => createCircle(180, 660), beatToMs(174.5));
setTimeout(() => createCircle(340, 585), beatToMs(175.5));
setTimeout(() => createCircle(180, 585), beatToMs(175.5));
setTimeout(() => createCircle(270, 155), beatToMs(177));
setTimeout(() => createCircle(270, 260), beatToMs(178.4));
setTimeout(() => createCircle(270, 365), beatToMs(179));
setTimeout(() => createCircle(170, 665), beatToMs(180.5));
setTimeout(() => createCircle(370, 665), beatToMs(181));
setTimeout(() => createCircle(370, 465), beatToMs(182));
setTimeout(() => createCircle(170, 465), beatToMs(183));
setTimeout(() => createCircle(270, 820), beatToMs(185));
setTimeout(() => createCircle(270, 715), beatToMs(186));
setTimeout(() => createCircle(270, 610), beatToMs(187));
setTimeout(() => createCircle(170, 165), beatToMs(188.5));
setTimeout(() => createCircle(370, 165), beatToMs(189));
setTimeout(() => createCircle(370, 365), beatToMs(190));
setTimeout(() => createCircle(170, 365), beatToMs(191));
setTimeout(() => createCircle(280, 436), beatToMs(192));
setTimeout(() => createCircle(280, 336), beatToMs(197));
setTimeout(() => createCircle(280, 236), beatToMs(198.5));
setTimeout(() => createCircle(280, 136), beatToMs(200));
setTimeout(() => createCircle(117, 668), beatToMs(205));
setTimeout(() => createCircle(386, 315), beatToMs(208));
`.trim();

    // ==============================
    // 전역 상태
    // ==============================
    let gameArea, ctx;
    let score = 0;
    let circles = [];

    const IS_MOBILE = matchMedia("(pointer:coarse)").matches || /Android|iPhone|iPad|iPod/i.test(navigator.userAgent);
    // ✅ 링만 모바일에서 조금 더 크게 보이게(값만 조절하면 됨)
    // 이제 조정 가능한 변수로 변경
    let perfectRingScale = IS_MOBILE ? 1.0 : 1.0;

    const SYNC_VISUAL_DELAY_MS = IS_MOBILE ? 90 : 0;

    // 스크롤 잠금/해제
    let savedScrollY = 0;
    function lockScroll() {
      savedScrollY = window.scrollY || 0;
      document.body.classList.add("lock-scroll");
      document.body.style.top = `-${savedScrollY}px`;
    }
    function unlockScroll() {
      document.body.classList.remove("lock-scroll");
      const y = Math.abs(parseInt(document.body.style.top || "0", 10)) || 0;
      document.body.style.top = "";
      window.scrollTo(0, y);
    }

    // 상단바 모드(메뉴/점수)
    function setTopBarMode(mode) {
      const btnStart = document.getElementById("btnStart");
      const btnRank  = document.getElementById("btnRank");
      const scoreBox = document.getElementById("scoreBox");
      const btnRetry = document.getElementById("btnRetry");
      const topBar = document.getElementById("topBar");
      if (!btnStart || !btnRank || !scoreBox || !btnRetry) return;

      if (mode === "score") {
        btnStart.style.display = "none";
        btnRank.style.display  = "none";
        scoreBox.style.display = "flex";
        btnRetry.style.display = "inline-flex";
        if (topBar) topBar.classList.add("compact");
        document.body.classList.add("playing");
      } else {
        scoreBox.style.display = "none";
        btnRetry.style.display = "none";
        btnStart.style.display = "";
        btnRank.style.display  = "";
        if (topBar) topBar.classList.remove("compact");
        document.body.classList.remove("playing");
      }
    }
    function setTopScore(v) {
      const el = document.getElementById("scoreTop");
      if (el) el.textContent = String(v);
    }

    // ==============================
    // 논리 좌표 / 박자
    // ==============================
    const DESIGN_W = 540;
    const DESIGN_H = 960;
    const CENTER_X = () => DESIGN_W / 2;
    const CENTER_Y = () => DESIGN_H / 2;

    const BPM = 140;
    const MS_PER_BEAT = 60000 / BPM;
    function beatToMs(beat) { return beat * MS_PER_BEAT; }

    // ==============================
    // 노트/판정
    // ==============================
    const NOTE_START_R = 10;
    const TARGET = 42;
    const PERFECT_WINDOW = 6;
    const PERFECT_MIN = TARGET - PERFECT_WINDOW;
    const PERFECT_MAX = TARGET + PERFECT_WINDOW;
    const TOUCH_HIT_RADIUS = 40;
    const GOOD_WINDOW = 16;
    const GROW_PER_SEC = 26;

    function judge(r) {
      if (r > PERFECT_MIN && r < PERFECT_MAX) return { type: "perfect", pts: 100 };
      if (Math.abs(r - TARGET) <= GOOD_WINDOW) return { type: "good", pts: 50 };
      return { type: "miss", pts: 10 };
    }

    const imgJudgePerfect = new Image(); imgJudgePerfect.src = "assets/judge_perfect.png";
    const imgJudgeGood    = new Image(); imgJudgeGood.src    = "assets/good.png";
    const imgJudgeMiss    = new Image(); imgJudgeMiss.src    = "assets/miss.png";

    let judgePopups = []; // {x,y,img,born,life,size}
    const POPUP_LIFE_MS = 450;
    const JUDGE_POP_SIZE = TARGET * 2;
    function addJudgePopup(type, x, y) {
      const img =
        type === "perfect" ? imgJudgePerfect :
        type === "good"    ? imgJudgeGood :
                             imgJudgeMiss;

      judgePopups.push({
        x, y, img,
        born: performance.now(),
        life: POPUP_LIFE_MS,
        size: JUDGE_POP_SIZE
      });
    }

    // ==============================
    // 오디오
    // ==============================
    let bgm;
    const BGM_SRC = "assets/bgm_retro.mp3";
    const SFX_TICK_SRC = "assets/kick.mp3";

    let tickPool = [];
    let tickPoolIdx = 0;

    function initTickPool() {
      if (tickPool.length) return;
      for (let i = 0; i < 4; i++) {
        const a = new Audio(SFX_TICK_SRC);
        a.preload = "auto";
        a.volume = 1.0;
        tickPool.push(a);
      }
    }

    function primeBgm() {
      try {
        if (!bgm) bgm = new Audio(BGM_SRC);
        bgm.loop = false;
        bgm.volume = 0.5;
        bgm.currentTime = 0;

        const p = bgm.play();
        if (p && typeof p.then === "function") {
          p.then(() => { bgm.pause(); bgm.currentTime = 0; }).catch(()=>{});
        }
      } catch(e) {}
    }

    function primeTick() {
      initTickPool();
      for (const a of tickPool) {
        try {
          a.volume = 0;
          a.currentTime = 0;
          const p = a.play();
          if (p && typeof p.then === "function") {
            p.then(() => {
              a.pause();
              a.currentTime = 0;
              a.volume = 1.0;
            }).catch(() => { a.volume = 1.0; });
          } else {
            a.volume = 1.0;
          }
        } catch(e) {}
      }
    }

    function playTick() {
      initTickPool();
      const a = tickPool[tickPoolIdx % tickPool.length];
      tickPoolIdx++;
      try { a.currentTime = 0; a.volume = 1.0; a.play().catch(()=>{}); } catch(e) {}
    }

    function getSongMsRaw() {
      if (!bgm) return 0;
      return Math.max(0, Number(bgm.currentTime || 0) * 1000);
    }

    // ==============================
    // 배경 / 이미지
    // ==============================
    const imgNote = new Image(); imgNote.src = "assets/note.png";
    const imgRing = new Image(); imgRing.src = "assets/perfect_ring.png";

    const bgSky   = new Image(); bgSky.src   = "assets/bg_city_sky.png";
    const bgFar   = new Image(); bgFar.src   = "assets/bg_city_far.png";
    const bgNear  = new Image(); bgNear.src  = "assets/bg_city_near.png";
    const bgBlack = new Image(); bgBlack.src = "assets/bg_city_black.png";

    let bgX1 = 0, bgX2 = 0, bgX3 = 0, bgX4 = 0;
    const bgSpeed1 = 8, bgSpeed2 = 18, bgSpeed3 = 30, bgSpeed4 = 42;

    // ==============================
    // 캔버스 스케일링
    // ==============================
    const view = { cssW:0, cssH:0, dpr:1, scale:1, offsetX:0, offsetY:0 };

    function resizeCanvas() {
      if (!gameArea || !ctx) return;

      const containerW = gameArea.parentElement.clientWidth;
      const aspect = DESIGN_H / DESIGN_W;

      let cssW = containerW;
      let cssH = Math.round(cssW * aspect);

      const vh = window.innerHeight || document.documentElement.clientHeight || 0;
      const canvasTop = gameArea.getBoundingClientRect().top;
      const safeBottom = 8;
      const maxH = Math.max(200, Math.floor(vh - canvasTop - safeBottom));

      if (cssH > maxH) { cssH = maxH; cssW = Math.round(cssH / aspect); }

      view.cssW = cssW; view.cssH = cssH;

      const dpr = window.devicePixelRatio || 1;
      view.dpr = dpr;

      gameArea.style.width = cssW + "px";
      gameArea.style.height = cssH + "px";
      gameArea.width = Math.round(cssW * dpr);
      gameArea.height = Math.round(cssH * dpr);

      const scaleX = cssW / DESIGN_W;
      const scaleY = cssH / DESIGN_H;
      view.scale = Math.min(scaleX, scaleY);
      view.offsetX = (cssW - DESIGN_W * view.scale) / 2;
      view.offsetY = (cssH - DESIGN_H * view.scale) / 2;

      applyViewTransform();
    }

    function applyViewTransform() {
      ctx.setTransform(1, 0, 0, 1, 0, 0);
      ctx.setTransform(view.scale * view.dpr, 0, 0, view.scale * view.dpr,
                       view.offsetX * view.dpr, view.offsetY * view.dpr);
    }

    function clearFrame() {
      ctx.save();
      ctx.setTransform(1, 0, 0, 1, 0, 0);
      ctx.clearRect(0, 0, gameArea.width, gameArea.height);
      ctx.restore();
      applyViewTransform();
    }

    function drawScrollingLayer(img, xOffset, speedPxPerSec, dtSec) {
      if (!img || !img.complete || img.naturalWidth === 0) return xOffset;

      xOffset += speedPxPerSec * dtSec;

      const w = DESIGN_W;
      const h = DESIGN_H;

      const imgAspect = img.naturalWidth / img.naturalHeight;
      const drawH = h;
      const drawW = drawH * imgAspect;

      let x = -(xOffset % drawW);
      while (x < w) {
        ctx.drawImage(img, x, 0, drawW, drawH);
        x += drawW;
      }
      return xOffset;
    }

    // ==============================
    // 스폰(오디오 시간 기준) + 링 0.5초 먼저
    // ==============================
    let placements = [];
    function parsePlacementsFromCode(code) {
      const out = [];
      const re = /createCircle\(\s*(-?\d+)\s*,\s*(-?\d+)\s*\)\s*,\s*beatToMs\(\s*([0-9]+(?:\.[0-9]+)?)\s*\)/g;
      let m, idx = 0;
      while ((m = re.exec(code)) !== null) {
        out.push({ x: Number(m[1]), y: Number(m[2]), t: Number(m[3]), idx: idx++ });
      }
      out.sort((a,b) => (a.t - b.t) || (a.idx - b.idx));
      return out;
    }

    const PRE_RING_MS = 500;
    const rings = new Map();

    let spawnList = [];
    let nextRingIdx = 0;
    let nextSpawnIdx = 0;

    let lastPerfectMs = 0;

    function prepareSpawnList() {
      const leadMs = ((TARGET - NOTE_START_R) / GROW_PER_SEC) * 1000;

      spawnList = placements.map((p, i) => {
        const perfectMs = beatToMs(p.t);
        const spawnMs = Math.max(0, perfectMs - leadMs);
        const ringMs  = Math.max(0, spawnMs - PRE_RING_MS);
        return { x: p.x, y: p.y, ringMs, spawnMs, key: i };
      });

      lastPerfectMs = placements.length ? beatToMs(placements[placements.length - 1].t) : 0;

      nextRingIdx = 0;
      nextSpawnIdx = 0;
      rings.clear();
    }

    function drawPerfectRingAt(x, y) {
  const ringR = TARGET * perfectRingScale;

  if (imgRing.complete && imgRing.naturalWidth > 0) {
    const sizeP = ringR * 2;
    ctx.drawImage(imgRing, x - ringR, y - ringR, sizeP, sizeP);
  } else {
    ctx.save();
    ctx.strokeStyle = "red";
    ctx.setLineDash([10 / view.scale, 7 / view.scale]);
    ctx.beginPath();
    ctx.arc(x, y, ringR, 0, Math.PI * 2);
    ctx.stroke();
    ctx.restore();
  }
}


    function updateSpawnsBySong(songMsRaw) {
      const songMs = Math.max(0, songMsRaw - SYNC_VISUAL_DELAY_MS);

      while (nextRingIdx < spawnList.length && songMs >= spawnList[nextRingIdx].ringMs) {
        const it = spawnList[nextRingIdx];
        rings.set(it.key, { x: it.x, y: it.y });
        nextRingIdx++;
      }

      while (nextSpawnIdx < spawnList.length && songMs >= spawnList[nextSpawnIdx].spawnMs) {
        const it = spawnList[nextSpawnIdx];
        createCircle(it.x, it.y, it.key);
        nextSpawnIdx++;
      }
    }

    // ==============================
    // 입력 / 판정 처리
    // ==============================
    let isPlaying = false;

    function removeCircleAt(index) {
      const c = circles[index];
      if (c && typeof c.ringKey === "number") rings.delete(c.ringKey);
      circles.splice(index, 1);
    }

    function applyJudgeAndRemove(index) {
      const c = circles[index];
      const j = judge(c.radius);

      score += j.pts;
      setTopScore(score);

      addJudgePopup(j.type, c.x, c.y);
      removeCircleAt(index);
    }

    function attemptHitAt(x, y) {
      if (!isPlaying) return;

      let bestIdx = -1;
      let bestDist = Infinity;
      for (let i = 0; i < circles.length; i++) {
        const c = circles[i];
        const dist = Math.hypot(x - c.x, y - c.y);
        if (dist <= TOUCH_HIT_RADIUS && dist < bestDist) {
          bestDist = dist;
          bestIdx = i;
        }
      }
      if (bestIdx !== -1) applyJudgeAndRemove(bestIdx);
    }

    function attemptHitBestByRadius() {
      if (!isPlaying) return;
      if (circles.length === 0) return;

      let bestIdx = 0;
      let bestDiff = Infinity;
      for (let i = 0; i < circles.length; i++) {
        const diff = Math.abs(circles[i].radius - TARGET);
        if (diff < bestDiff) {
          bestDiff = diff;
          bestIdx = i;
        }
      }
      applyJudgeAndRemove(bestIdx);
    }

    function onKeyDown(e) {
      if (e.code !== "Space") return;
      attemptHitBestByRadius();
    }

    function screenToLogical(clientX, clientY) {
      const rect = gameArea.getBoundingClientRect();
      const cssX = clientX - rect.left;
      const cssY = clientY - rect.top;
      const x = (cssX - view.offsetX) / view.scale;
      const y = (cssY - view.offsetY) / view.scale;
      return { x, y };
    }

    function onPointerDown(e) {
      const { x, y } = screenToLogical(e.clientX, e.clientY);
      attemptHitAt(x, y);
    }

    let keyBound = false;
    let resizeBound = false;
    function bindKeyOnce() {
      if (keyBound) return;
      keyBound = true;
      document.addEventListener("keydown", onKeyDown, { passive: true });
    }
    function bindResizeOnce() {
      if (resizeBound) return;
      resizeBound = true;
      window.addEventListener("resize", resizeCanvas);
      window.addEventListener("orientationchange", () => setTimeout(resizeCanvas, 50));
    }

    // ==============================
    // CLEAR + 저장
    // ==============================
    let gameEnded = false;
    const clearState = { active:false, until:0, backAt:0 };

    async function endGameClear(reason="chart_end") {
      if (gameEnded) return;
      gameEnded = true;

      isPlaying = false;
      countdown.active = false;

      try { if (bgm) bgm.pause(); } catch(e) {}

      const now = performance.now();
      clearState.active = true;
      clearState.until = now + 1600;
      clearState.backAt = now + 2200;

      const p = window._player || {};
      const payload = {
        studentId: (p.id || "").trim(),
        name: (p.name || "").trim(),
        score,
        playTimeMs: Math.round(getSongMsRaw())
      };

      console.log("[CLEAR]", reason, payload);

      try {
        await submitScore(payload);
        console.log("[submitScore] ok");
      } catch (err) {
        console.warn("[submitScore] failed", err);
      }
    }

    // ==============================
    // 카운트다운 / 루프
    // ==============================
    const countdown = {
      active:false,
      startAt:0,
      started:false,
      startShownUntil:0,
      tickStage:0
    };
    const COUNTDOWN_IDLE_MS = 1000;
    const COUNTDOWN_STEP_MS = 1000;
    const START_FLASH_MS = 650;

    let lastFrameAt = 0;
    let rafId = 0;
    let loopActive = false;

    function resetChartRuntime() {
      circles = [];
      rings.clear();
      judgePopups = [];
      score = 0;
      setTopScore(0);

      isPlaying = false;
      gameEnded = false;
      clearState.active = false;

      nextRingIdx = 0;
      nextSpawnIdx = 0;

      if (bgm) { try { bgm.pause(); bgm.currentTime = 0; } catch(e) {} }
    }

    function startCountdown() {
      resetChartRuntime();

      countdown.active = true;
      countdown.startAt = performance.now();
      countdown.started = false;
      countdown.startShownUntil = 0;
      countdown.tickStage = 0;
    }

    function startLoop() {
      loopActive = true;
      if (rafId) cancelAnimationFrame(rafId);
      lastFrameAt = 0;
      rafId = requestAnimationFrame(updateGame);
    }
    function stopLoop() {
      loopActive = false;
      if (rafId) cancelAnimationFrame(rafId);
      rafId = 0;
    }

    function updateGame(now) {
      if (!loopActive || !ctx) return;

      if (!lastFrameAt) lastFrameAt = now;
      const dtSec = Math.min(0.05, (now - lastFrameAt) / 1000);
      lastFrameAt = now;

      clearFrame();

      // 배경
      bgX1 = drawScrollingLayer(bgSky,  bgX1, bgSpeed1, dtSec);
      bgX2 = drawScrollingLayer(bgFar,  bgX2, bgSpeed2, dtSec);
      bgX3 = drawScrollingLayer(bgNear, bgX3, bgSpeed3, dtSec);
      bgX4 = drawScrollingLayer(bgBlack,bgX4, bgSpeed4, dtSec);

      // 카운트다운 + 틱
      if (countdown.active) {
        const t = now - countdown.startAt;

        if (t >= COUNTDOWN_IDLE_MS && t < COUNTDOWN_IDLE_MS + 3 * COUNTDOWN_STEP_MS) {
          const phase = t - COUNTDOWN_IDLE_MS;
          const stage = Math.floor(phase / COUNTDOWN_STEP_MS);
          while (countdown.tickStage <= stage && countdown.tickStage < 3) {
            playTick();
            countdown.tickStage++;
          }
        }

        let text = "";
        if (t < COUNTDOWN_IDLE_MS) text = "";
        else if (t < COUNTDOWN_IDLE_MS + 1 * COUNTDOWN_STEP_MS) text = "3";
        else if (t < COUNTDOWN_IDLE_MS + 2 * COUNTDOWN_STEP_MS) text = "2";
        else if (t < COUNTDOWN_IDLE_MS + 3 * COUNTDOWN_STEP_MS) text = "1";
        else {
          if (!countdown.started) {
            countdown.started = true;
            countdown.startShownUntil = now + START_FLASH_MS;

            isPlaying = true;
            circles = [];
            rings.clear();
            judgePopups = [];
            nextRingIdx = 0;
            nextSpawnIdx = 0;

            try {
              if (bgm) {
                bgm.currentTime = 0;
                bgm.volume = 0.5;
                bgm.play().catch(()=>{});
              }
            } catch(e) {}
          }
          if (now < countdown.startShownUntil) text = "START";
          else countdown.active = false;
        }

        if (text) {
          ctx.save();
          ctx.textAlign = "center";
          ctx.textBaseline = "middle";
          ctx.fillStyle = "rgba(255,255,255,0.95)";
          ctx.shadowColor = "rgba(0,0,0,0.65)";
          ctx.shadowBlur = 14;
          ctx.font = "900 140px system-ui, -apple-system, Segoe UI, Roboto, sans-serif";
          ctx.fillText(text, CENTER_X(), CENTER_Y());
          ctx.restore();
        }
      }

      // 오디오 기준 스폰
      const songMsRaw = getSongMsRaw();
      if (isPlaying) updateSpawnsBySong(songMsRaw);

      // 퍼펙트 링
      for (const r of rings.values()) drawPerfectRingAt(r.x, r.y);

      // 노트 업데이트/그리기
      const grow = GROW_PER_SEC * dtSec;
      for (const c of circles) {
        c.radius += grow;
        if (imgNote.complete && imgNote.naturalWidth > 0) {
          const size = c.radius * 2;
          ctx.drawImage(imgNote, c.x - c.radius, c.y - c.radius, size, size);
        } else {
          ctx.beginPath();
          ctx.strokeStyle = "#bfffbf";
          ctx.arc(c.x, c.y, c.radius, 0, Math.PI * 2);
          ctx.stroke();
        }
      }

      // 미스(안 누르고 사라짐)
      for (let i = circles.length - 1; i >= 0; i--) {
        if (circles[i].radius > 85) {
          if (isPlaying) addJudgePopup("miss", circles[i].x, circles[i].y);
          removeCircleAt(i);
        }
      }

      // 판정 팝업
      const nowMs = performance.now();
      judgePopups = judgePopups.filter(p => nowMs - p.born < p.life);
      for (const p of judgePopups) {
        const t = (nowMs - p.born) / p.life;
        const a = 1 - t;
        if (!p.img.complete || p.img.naturalWidth === 0) continue;

        ctx.save();
        ctx.globalAlpha = a;
        ctx.drawImage(p.img, p.x - p.size/2, p.y - p.size/2, p.size, p.size);
        ctx.restore();
      }

      // CLEAR 오버레이
      if (clearState.active) {
        ctx.save();
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillStyle = "rgba(255,255,255,0.95)";
        ctx.shadowColor = "rgba(0,0,0,0.75)";
        ctx.shadowBlur = 18;
        ctx.font = "900 140px system-ui, -apple-system, Segoe UI, Roboto, sans-serif";
        ctx.fillText("CLEAR", CENTER_X(), CENTER_Y() - 20);
        ctx.font = "800 54px system-ui, -apple-system, Segoe UI, Roboto, sans-serif";
        ctx.fillText(`SCORE ${score}`, CENTER_X(), CENTER_Y() + 90);
        ctx.restore();

        if (nowMs >= clearState.backAt) {
          startGame(); // 입력 화면으로 복귀
          return;
        }
      }

      // 차트 종료 감지
      if (!gameEnded && isPlaying && !countdown.active) {
        const songMs = Math.max(0, songMsRaw - SYNC_VISUAL_DELAY_MS);
        const doneSpawning = nextSpawnIdx >= spawnList.length;
        const noNotes = circles.length === 0;
        const END_GRACE_MS = 1800;

        if (doneSpawning && noNotes && songMs >= lastPerfectMs + END_GRACE_MS) {
          endGameClear("chart_end");
        }
      }

      rafId = requestAnimationFrame(updateGame);
    }

    // ==============================
    // UI: 입력 → 시작(입력 없으면 시작 불가)
    // ==============================
    // preview canvas state
    let previewCanvas, previewCtx;

    function renderInputScreen() {
      document.getElementById("content").innerHTML = `
        <div class="input-row">
          <label for="studentId">학번</label>
          <input id="studentId" type="text" placeholder="예) 30123" inputmode="numeric" autocomplete="off">
        </div>
        <div class="input-row">
          <label for="name">이름</label>
          <input id="name" type="text" placeholder="이름을 입력하세요" autocomplete="off">
        </div>

        <div class="preview-row">
          <div class="preview-wrap">
            <canvas id="previewCanvas" class="preview-canvas"></canvas>
            <div class="preview-controls">
              <label>퍼펙트 링 크기 조정</label>
              <div class="range-row">
                <input id="ringScaleRange" type="range" min="0.5" max="1.8" step="0.01" value="${perfectRingScale}">
                <div style="min-width:44px; text-align:center;">x <span id="ringScaleVal">${perfectRingScale.toFixed(2)}</span></div>
              </div>
              <div class="muted">※ 실시간 미리보기: 링(x)과 퍼펙트 크기(녹색 노트)를 비교하세요.</div>
            </div>
          </div>
        </div>

        <div class="bar">
          <button id="btnGo">입력 완료</button>
        </div>
        <p class="muted">학번/이름을 입력해야 게임이 시작됩니다.</p>
      `;

      previewCanvas = document.getElementById('previewCanvas');
      previewCtx = previewCanvas.getContext('2d');

      function resizePreviewCanvas() {
        if (!previewCanvas) return;
        const cssW = previewCanvas.clientWidth;
        const cssH = previewCanvas.clientHeight;
        const dpr = window.devicePixelRatio || 1;
        previewCanvas.width = Math.round(cssW * dpr);
        previewCanvas.height = Math.round(cssH * dpr);
        previewCtx.setTransform(dpr,0,0,dpr,0,0);
      }

      function drawPreview() {
        if (!previewCtx || !previewCanvas) return;
        resizePreviewCanvas();
        const w = previewCanvas.clientWidth;
        const h = previewCanvas.clientHeight;

        previewCtx.clearRect(0,0,w,h);
        previewCtx.save();
        previewCtx.translate(w/2, h/2);

        // draw perfect note (target) as filled circle or image
        const noteR = TARGET; // logical px
        const ringR = TARGET * perfectRingScale;

        if (imgNote.complete && imgNote.naturalWidth > 0) {
          const size = noteR * 2;
          previewCtx.drawImage(imgNote, -noteR, -noteR, size, size);
        } else {
          previewCtx.beginPath();
          previewCtx.fillStyle = '#2ecc71';
          previewCtx.arc(0,0,noteR,0,Math.PI*2);
          previewCtx.fill();
        }

        // ring
        if (imgRing.complete && imgRing.naturalWidth > 0) {
          const size = ringR * 2;
          previewCtx.drawImage(imgRing, -ringR, -ringR, size, size);
        } else {
          previewCtx.beginPath();
          previewCtx.strokeStyle = '#ff4d4d';
          previewCtx.lineWidth = 2;
          previewCtx.setLineDash([6,4]);
          previewCtx.arc(0,0,ringR,0,Math.PI*2);
          previewCtx.stroke();
        }

        previewCtx.restore();
      }

      // hook up slider
      const range = document.getElementById('ringScaleRange');
      const valEl = document.getElementById('ringScaleVal');
      range.addEventListener('input', (e) => {
        const v = Number(e.target.value);
        perfectRingScale = v;
        valEl.textContent = v.toFixed(2);
        drawPreview();
      }, { passive: true });

      window.addEventListener('resize', () => setTimeout(drawPreview, 50));

      const idEl = document.getElementById("studentId");
      const nameEl = document.getElementById("name");
      const goBtn = document.getElementById("btnGo");

      function validate() {
        const id = (idEl.value || "").trim();
        const nm = (nameEl.value || "").trim();

        const okId = id.length > 0;
        const okNm = nm.length > 0;

        idEl.classList.toggle("invalid", !okId);
        nameEl.classList.toggle("invalid", !okNm);

        goBtn.disabled = !(okId && okNm);
        return okId && okNm;
      }

      idEl.addEventListener("input", validate);
      nameEl.addEventListener("input", validate);

      goBtn.addEventListener("click", () => {
        if (!validate()) {
          alert("학번과 이름을 입력해 주세요.");
          return;
        }
        gameStart();
      });

      // initial draw
      setTimeout(drawPreview, 50);

      validate();
    }

    // ==============================
    // 화면 구성
    // ==============================
    function startGame() {
      stopLoop();
      unlockScroll();
      setTopBarMode("menu");

      isPlaying = false;
      resetChartRuntime();

      if (bgm) { try { bgm.pause(); } catch(e) {} }

      renderInputScreen();
    }

    function gameStart() {
      // ✅ 입력 검증(혹시 버튼이 강제로 눌려도 막음)
      const idEl = document.getElementById("studentId");
      const nameEl = document.getElementById("name");
      const id = (idEl?.value || "").trim();
      const name = (nameEl?.value || "").trim();
      if (!id || !name) {
        alert("학번과 이름을 입력해 주세요.");
        if (idEl) idEl.classList.toggle("invalid", !id);
        if (nameEl) nameEl.classList.toggle("invalid", !name);
        return;
      }

      window._player = { id, name };

      lockScroll();
      setTopBarMode("score");

      document.getElementById("content").innerHTML = `<canvas id="gameCanvas"></canvas>`;

      gameArea = document.getElementById("gameCanvas");
      ctx = gameArea.getContext("2d");

      bindKeyOnce();
      gameArea.addEventListener("pointerdown", onPointerDown, { passive: true });
      bindResizeOnce();

      placements = parsePlacementsFromCode(PLACEMENT_CODE);
      prepareSpawnList();

      primeBgm();
      primeTick();
      startCountdown();

      resizeCanvas();
      setTimeout(resizeCanvas, 0);

      startLoop();
    }

    // ✅ 플레이 중 다시하기(입력 정보 유지)
    function retryGame() {
      if (!gameArea || !ctx) return;
      placements = parsePlacementsFromCode(PLACEMENT_CODE);
      prepareSpawnList();
      startCountdown(); // score/circles/오디오 리셋 + 카운트다운
      if (!loopActive) startLoop();
    }

    // ==============================
    // 랭킹 UI
    // ==============================
    function msToTime(ms) {
      const s = Math.max(0, Math.floor(ms / 1000));
      const mm = String(Math.floor(s / 60)).padStart(2, "0");
      const ss = String(s % 60).padStart(2, "0");
      return `${mm}:${ss}`;
    }

    async function showRanking() {
      stopLoop();
      unlockScroll();
      setTopBarMode("menu");

      isPlaying = false;
      resetChartRuntime();

      document.getElementById("content").innerHTML = `
        <div class="rank-wrap">
          <div class="rank-head">
            <strong>랭킹</strong>
            <div class="rank-actions">
              <button id="btnRefresh">새로고침</button>
              <button id="btnBack">메뉴로</button>
            </div>
          </div>
          <div style="padding:12px 14px" class="muted" id="rankStatus">불러오는 중...</div>
          <div style="overflow:auto">
            <table class="rank-table" id="rankTable" style="display:none">
              <thead>
                <tr>
                  <th style="width:60px">#</th>
                  <th>이름</th>
                  <th style="width:90px">학번</th>
                  <th style="width:90px">점수</th>
                  <th style="width:90px">시간</th>
                </tr>
              </thead>
              <tbody id="rankBody"></tbody>
            </table>
          </div>
        </div>
        <p class="muted">※ Firestore 읽기 권한이 필요합니다.</p>
      `;

      const statusEl = document.getElementById("rankStatus");
      const tableEl = document.getElementById("rankTable");
      const bodyEl = document.getElementById("rankBody");

      async function load() {
        statusEl.textContent = "불러오는 중...";
        tableEl.style.display = "none";
        bodyEl.innerHTML = "";

        try {
          const rows = await fetchTopScores(20);
          if (!rows.length) {
            statusEl.textContent = "아직 기록이 없습니다.";
            return;
          }

          statusEl.textContent = "";
          tableEl.style.display = "table";

          rows.forEach((r, i) => {
            const tr = document.createElement("tr");
            const nm = (r.name || "").toString();
            const sid = (r.studentId || "").toString();
            const sc = Number(r.score || 0);
            const pt = Number(r.playTimeMs || 0);

            tr.innerHTML = `
              <td>${i + 1}</td>
              <td>${escapeHtml(nm)}</td>
              <td>${escapeHtml(sid)}</td>
              <td>${sc}</td>
              <td>${msToTime(pt)}</td>
            `;
            bodyEl.appendChild(tr);
          });
        } catch (e) {
          console.warn(e);
          statusEl.textContent = "랭킹을 불러오지 못했습니다. (권한/네트워크 확인)";
        }
      }

      document.getElementById("btnRefresh").addEventListener("click", load);
      document.getElementById("btnBack").addEventListener("click", startGame);

      await load();
    }

    function escapeHtml(s) {
      return String(s)
        .replaceAll("&","&amp;")
        .replaceAll("<","&lt;")
        .replaceAll(">","&gt;")
        .replaceAll('"',"&quot;")
        .replaceAll("'","&#039;");
    }

    // ==============================
    // 노트 생성
    // ==============================
    function createCircle(x, y, ringKey) {
      circles.push({ x, y, radius: NOTE_START_R, ringKey });
    }

    // ==============================
    // 상단 버튼 연결
    // ==============================
    document.getElementById("btnStart").addEventListener("click", startGame);
    document.getElementById("btnRank").addEventListener("click", showRanking);
    document.getElementById("btnRetry").addEventListener("click", retryGame);

    // 전역(혹시 필요할 때)
    window.startGame = startGame;
    window.showRanking = showRanking;
    window.gameStart = gameStart;
    window.createCircle = createCircle;

    // 첫 진입
    startGame();
  </script>
</body>
</html>

